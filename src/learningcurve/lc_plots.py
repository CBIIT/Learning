import os
import sys
import warnings
from pathlib import Path

import numpy as np
import pandas as pd

import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn import metrics
from scipy import optimize

        
def capitalize_metric(met):
    return ' '.join(s.capitalize() for s in met.split('_'))      
    
    
def scale_ticks_params(tick_scale='linear'):
    """ Helper function for learning curve plots.
    Args:
        tick_scale : available values are [linear, log2, log10]
    """
    if tick_scale == 'linear':
        base = None
        label_scale = 'Linear Scale'
    else:
        if tick_scale == 'log2':
            base = 2
            label_scale = 'Log2 Scale'
        elif tick_scale == 'log10':
            base = 10
            label_scale = 'Log10 Scale'
        else:
            raise ValueError('The specified tick scale is not supported.')
    return base, label_scale    
    
    
def set_yticks(ax, ylim=None):
    """ Adjust y ticks. """
    ax.get_yaxis().set_major_formatter( matplotlib.ticker.ScalarFormatter() )
    if (ylim is None):
        ylim = ax.get_ylim()
    ylim = [max(v, np.finfo(float).eps) for v in ylim]
    ylim_log = np.log2(ylim)
    ylabels_log = np.logspace(ylim_log[0], ylim_log[1], num=5, base=2)
    ylabels_log = np.around(ylabels_log, decimals=4)
    ax.set_yticks(ylabels_log)
    return ax    


def set_xticks(ax, xlabels_log=None, show_log=True):
    """ Adjust x ticks in logarithmic scale.
    Args:
        xlabels_log : x tick labels in log scale
        show_log : determines how to show the numbers
    """
    if show_log is False:
        ax.set_xscale('log', basex=2)  # show regular numbers (512, 1024, ...)
        ax.get_xaxis().set_major_formatter( matplotlib.ticker.ScalarFormatter() )
    else:
        ax.get_xaxis().set_major_formatter( matplotlib.ticker.ScalarFormatter() )
        ax.set_xscale('log', basex=2)  # show power number (2^9, 2^10, ...)
        
    if xlabels_log is not None:
        ax.set_xticks(xlabels_log)
    return ax


def plot_lc_many_metric(scores, outdir:Path, metrics:list=None, **plot_args):
    """ Iterate over metrics and plot LC data for each metric. """
    if metrics is None:
        metrics = scores['metric'].unique()

    for met in metrics:
        if met not in metrics:
            continue
        else:
            ax = plot_lc_single_metric(scores, metric_name=met, **plot_args)
            ax.legend(frameon=True, fontsize=10, loc='best')
            ax.grid(True)
            plt.tight_layout()
            plt.savefig(outdir/(f'lc.{met}.png'), dpi=200)
            del ax

    return None
    

def shade_fill_between(df, ax=None, alpha=0.3):
    min_v = df.groupby(['metric', 'tr_size']).agg({'score': 'min'}).reset_index()
    max_v = df.groupby(['metric', 'tr_size']).agg({'score': 'max'}).reset_index()
    med_v = df.groupby(['metric', 'tr_size']).agg({'score': 'median'}).reset_index()
    
    min_v = min_v.rename(columns={'score': 'min'})
    max_v = max_v.rename(columns={'score': 'max'})
    med_v = med_v.rename(columns={'score': 'median'})

    vv = min_v.merge(max_v, on='tr_size', how='inner')
    vv = vv.merge(med_v, on='tr_size', how='inner')
    vv[['metric', 'tr_size', 'min', 'max', 'median']]

    ax.fill_between(x=vv['tr_size'].values,
                    y1=vv['min'].values,
                    y2=vv['max'].values,
                    alpha=alpha)
    return ax
    
    
def plot_lc_single_metric(scores, metric_name:str, tr_set:str='te',
                          plot_median=True, plot_shade=False,
                          ax=None, **plot_args):
    """
    Plots LC_raw (points from multiple data split), icnluding the median
    score per subset size. 'scores' is the aggregated dataframe of scores
    generated by agg_scores() (see agg_results_from_runs.py)
    Args:
        scores : aggregated dataframe from all scores of multiple runs.
        metrics : metrics to plot (if None, plot all available)
    Returns:
        ax :
    """
    df = scores[ (scores['metric']==metric_name) & (scores['set']==tr_set) ].reset_index(drop=True)

    # Plot all scores
    ax = plot_lc(
        x=df['tr_size'], y=df['score'], yerr=None,
        metric_name=metric_name, label='$LC_{raw}$',
        ax=ax, **plot_args);

    # Plot median
    if plot_median:
        aa = df.groupby(['metric', 'tr_size']).agg({'score': 'median'})
        aa = aa.reset_index().rename(columns={'score': 'median'})
        ax = plot_lc(
            x=aa['tr_size'], y=aa['median'], yerr=None,
            ls='--', marker='.', alpha=0.7, color='r',
            metric_name=metric_name, label='Median', 
            ax=ax, **plot_args);
        
    if plot_shade:
        ax = shade_fill_between(df, ax=ax, alpha=0.3)

    # ax.tick_params(axis='both', labelsize=11)
    # ax = set_yticks(ax)
    ax.grid(False)
    return ax    
    

def plot_lc(x, y, yerr=None, metric_name:str='score',
            xtick_scale:str='log2', ytick_scale:str='log2',
            xlabels_log:list=None, xlim:list=None, ylim:list=None, title:str=None, figsize=(7, 5),
            ls='', marker='.', fontsize=13, legend_fontsize=11,
            color=None, markerfacecolor=None, markeredgecolor=None, alpha=0.7,
            label:str=None, ax=None):
    """
    NOTE! The previous name of this func is plot_lrn_crv_new().
    This is basic plot plotting function for learning curves.
    It takes train set size in x and score in y, and generates a learning curve plot.
    
    Returns:
        ax : ax handle from existing plot (this allows to plot results from different runs for comparison)
    """
    x = x.ravel()
    y = y.ravel()
    
    # Init figure
    if ax is None:
        fig, ax = plt.subplots(figsize=figsize)
    
    if (markerfacecolor is None) & (markeredgecolor is None):
        markerfacecolor = color
        markeredgecolor = color
    
    # Plot raw data
    if yerr is None:
        p = ax.plot(x, y, marker=marker, ls=ls, markerfacecolor=color, markeredgecolor=color, color=color, alpha=alpha, label=label);
    else:
        p = ax.errorbar(x, y, yerr, marker=marker, ls=ls, markerfacecolor=color, markeredgecolor=color, ecolor=color, alpha=alpha, label=label);
    c = p[0].get_color()

    basex, xlabel_scale = scale_ticks_params(tick_scale=xtick_scale)
    basey, ylabel_scale = scale_ticks_params(tick_scale=ytick_scale)
    
    ax.set_xlabel(f'Training Dataset Size ({xlabel_scale})', fontsize=fontsize)
    if 'log' in xlabel_scale.lower():
        ax.set_xscale('log', basex=basex)

    ylabel = capitalize_metric( metric_name )
    ax.set_ylabel(f'{ylabel} ({ylabel_scale})', fontsize=fontsize)
    if 'log' in ylabel_scale.lower():
        ax.set_yscale('log', basey=basey)        
        
    if ylim is not None:  ax.set_ylim(ylim)
    if xlim is not None:  ax.set_ylim(xlim)
    if title is not None: ax.set_title(title)
    
    # Legend loc --> stackoverflow.com/questions/4700614/how-to-put-the-legend-out-of-the-plot/43439132#43439132
    if label is not None:
        ax.legend(frameon=True, fontsize=legend_fontsize, bbox_to_anchor=(1.02, 1), loc='upper left')
    ax.grid(False)

    ax.tick_params(axis='both', labelsize=11)
    if ytick_scale == 'log2':
        ax = set_yticks(ax)
    if xtick_scale == 'log2':
        ax = set_xticks(ax, xlabels_log)
    return ax